# Final Milestone: 

### Summary:  

In Milestone 1, we used a naïve approach to read in the dataset and replace abbreviation with the keywords. With this following pseudocode: 
 
f(D, A) = D' for i = 1 to n:  for j = 1 to m:  if d[i] = a[j]:  d[i] = b[j]  break  D'.append(d[i]) return D'

In Milestone 2 we implemented a hash table as an improvement upon the naïve algorithm and it provided a good balance of efficiency and memory usage for this problem, making it a good choice for storing the dictionary of abbreviations. Bringing down the O(nm) complexity to O(1) in lookup search time.

In Milestone 3: We compiled sample files in a single csv formatted document, as the input file and performed graphical analysis on the runtime of our algorithms. We utilised the python’s Pandas package to set the data frames, and matplotlib.pyplot package to generate the graph results.

In the final Milestone, we are testing our improved algorithm – hashMap with a sample csv file and using the dictionary in our code to lookup keywords.

### Running Time for Algorithm A: {Plot here}

Space complexity: 


Time Complexity:



### Running Time for Algorithm B: {Plot here}


Space complexity:


Time Complexity:
